## Table of Contents
- [5장. 데이터베이스 조작이 편해지는 ORM](#5장-데이터베이스-조작이-편해지는-orm)
  - [5.1 데이터베이스란?](#51-데이터베이스란)
    - [5.1.1 데이터베이스 관리자 DBMS](#511-데이터베이스-관리자-dbms)
      - [관계형 DBMS](#관계형-dbms)
      - [H2, MySQL](#h2-mysql)
      - [꼭 알아야 할 데이터베이스 용어](#꼭-알아야-할-데이터베이스-용어)
    - [5.2 ORM(Object−Relational Mapping)이란?](#52-ormobjectrelational-mapping이란)
  - [5.3 JPA(Java persistence API)와 하이버네이트(Hibernate)?](#53-jpajava-persistence-api와-하이버네이트hibernate)
    - [5.3.1 엔티티 매니저란?](#531-엔티티-매니저란)
      - [엔티티(Entity)](#엔티티entity)
      - [엔티티 매니저(Entity manager)](#엔티티-매니저entity-manager)
    - [5.3.2 영속성 컨텍스트란?](#532-영속성-컨텍스트란)
      - [1차 캐시](#1차-캐시)
      - [쓰기 지연(transactional write-behind)](#쓰기-지연transactional-write-behind)
      - [변경 감지](#변경-감지)
      - [지연 로딩(lazy loading)](#지연-로딩lazy-loading)
    - [5.3.3 엔티티의 상태](#533-엔티티의-상태)
  - [5.4 스프링 데이터와 스프링 데이터 JPA](#54-스프링-데이터와-스프링-데이터-jpa)
    - [5.4.1 스프링 데이터 JPA란?](#541-스프링-데이터-jpa란)
    - [5.4.2 스프링 데이터 JPA에서 제공하는 메서드 사용해보기](#542-스프링-데이터-jpa에서-제공하는-메서드-사용해보기)
      - [01 단계](#01-단계)
  - [5.5 예제 코드 살펴보기](#55-예제-코드-살펴보기)
    - [1단계](#1단계)
      - [1. `@Entity`](#1-entity)
      - [2. `protected` 기본 생성자](#2-protected-기본-생성자)
      - [3. `@Id`](#3-id)
      - [4.`@GeneratedValue`](#4generatedvalue)
      - [5.`@Column`](#5column)
    - [2단계](#2단계)
  - [핵심 요약](#핵심-요약)


# 5장. 데이터베이스 조작이 편해지는 ORM
- **학습 목표**: SQL을 몰라도 데이터베이스를 조작할 수 있게 해주는 편리한 도구인 ORM을 공부하겠습니다. ORM은 SQL공부를 한 적이 있다면 그 편리함을 더 크게 느낄 수 있는 도구인데요, 여기서는 스프링 부트의 ORM 기술 표준인 **스프링 JPA**와 이를 구현하기 위한 **하이버네이트**를 사용합니다.

- **핵심 키워드**
  - DBMS
  - ORM
  - JPA
  - 하이버네이트
  - 엔티티
  - 영속성 컨텍스트
  - 스프링 데이터 JPA

```mermaid
graph LR
    A[데이터베이스란?]
    B[ORM이란?]
    C[JPA와 하이버네이트?]
    D[스프링 데이터와 스프링 데이터 JPA]
    E[예제 코드 살펴보기]
    A --> B --> C --> D --> E
```

## 5.1 데이터베이스란?
데이터베이스는 데이터를 매우 효율적으로 보관하고 꺼내볼 수 있는 곳입니다. 데이터베이스를 사용하면 얻을 수 있는 가장 큰 이점은 굉장히 많은 사람이 안전하게 데이터를 사용하고, 관리할 수 있다는 것이죠.

### 5.1.1 데이터베이스 관리자 DBMS
이떄 데이터베이스를 관리하기 위한 소프트웨어를 DBMS 
(database management system)라고 합니다. 

데이터베이스는 많은 사람이 공유할 수 있어야 하므로 **동시 접근**을 할 수 있어야 합니다. 이 외에도 많은 요구사항이 있는데요. 

DBMS는 이런 요구사항을 만족하면서도 효율적으로 데이터베이스를 관리하고 운영합니다. 흔히 데이터베이스라고 알고 있는 MySQL, Oracle은 사실 DBMS인 것이죠. 

DBMS는 관리 특징에 따라서 **관계형, 객체-관계형, 도큐먼트형, 비관계형 등으로 분류**합니다. 가장 많이 사용하는 DBMS는 관계형입니다.

#### 관계형 DBMS
관계형 DBMS(relational DBMS, RDBMS)라고 부릅니다.

관계형이라는 말을 쓰는 이유는 이 DBMS가 관계형 모델을 기반으로 하기 떄문인데요. RDBMS는 어렵게 생각할 필요 없이 **테이블 형태로 이루어진 데이터 저장소**를 생각하면 됩니다. 

예를 들어 회원 테이블이 있다고 가정하면 각 행은 고유의 키, 즉, 아이디를 가지고 있고, 이메일, 나이와 같은 회원과 관련된 값들이 들어갑니다.

| ID | 이메일 | 나이 |
| :---: | :---: | :---: |
| 1 | a@test.com | 10 |
| 2 | b@test.com | 20 |
| 3 | c@test.com | 30 |

이때 데이터 1, a@test.com, 10 을 묶어서 한 줄을 **행**이라고 하고, ID, 이메일, 나이와 같은 구분을 **열**이라고 합니다.

#### H2, MySQL
이 책에서 사용할 RDBMS는 **H2, MySQL**입니다. 

H2는 자바로 작성되어 있는 RDBMS입니다. 조금 더 구체적으로 설명하면 스프링 부트가 지원하는 인메모리 관계형 데이터베이스인데요. 

H2는 데이터를 다른 공간에 따로 보관하는 것이 아니라 애플리케이션 자체 내부에 데이터를 저장하는 특징이 있습니다. 그래서 애플리케이션을 다시 실행하면 데이터는 초기화가 되죠. 하지만 간편하게 사용하기 좋아서 개발 시에는 테스트 용도로 많이 사용합니다.

실제 서비스에는 사용하지 않죠. 실제 서비스에는 MySQL과 같은 제품을 많이 사용합니다. 이 책에서도 마찬가지로 개발 시에는 H2를, 실제 서비스로 올릴 때는 MySQL을 사용할 예정입니다.

<details>
<summary> <b> H2, 인메모리 RDBMS </b> </summary> <br/>

인메모리 테이블과 디스크 기반 테이블을 둘 다 생성할 수 있습니다.

Java Spring에서 H2를 사용하면, 개발 및 테스트 단계에서 실제 데이터베이스 시스템을 모방할 수 있습니다. 

Spring Boot는 H2와 같은 인메모리 데이터베이스를 쉽게 설정하고 사용할 수 있는 기능을 제공합니다.

H2 데이터베이스는 기본적으로 인메모리 모드에서 실행되므로, 애플리케이션을 재시작할 때마다 데이터가 사라집니다. 이를 방지하기 위해, 파일 기반의 저장소를 사용하도록 설정할 수 있습니다.

마지막으로, H2 데이터베이스는 SQL 스크립트를 사용하여 초기화할 수 있습니다. 이 스크립트는 데이터베이스 테이블을 생성하고, 필요한 경우 초기 데이터를 채워 넣는 데 사용될 수 있습니다.

<hr>

H2 데이터베이스에서 인메모리 테이블과 디스크 기반 테이블은 데이터 저장 방식에 차이가 있습니다.

- 인메모리 테이블: 이 테이블은 메모리에 저장되므로 데이터 접근 속도가 매우 빠릅니다. 그러나 애플리케이션을 종료하면 데이터가 사라지므로 주로 개발 및 테스트 환경에서 사용됩니다.
- 디스크 기반 테이블: 이 테이블은 디스크에 저장되므로 애플리케이션을 종료해도 데이터가 유지됩니다. 그러나 메모리에 비해 디스크 접근 속도가 느리므로, 데이터 접근 속도는 인메모리 테이블보다 느릴 수 있습니다.

또한, 인덱스 유형도 다릅니다. 
- 인메모리 테이블의 경우 해시 테이블이나 트리를 사용할 수 있고
- 디스크 기반 테이블의 경우 B-트리를 사용할 수 있습니다. 

이러한 차이는 각 테이블 유형의 성능과 사용 사례에 영향을 미칠 수 있습니다.

__참고 링크__
- [HEROJOON - Spring Boot에 H2 Database 설정, H2 Console 띄우기](https://herojoon-dev.tistory.com/141)
- [Baeldung - Spring Boot With H2 Database](https://www.baeldung.com/spring-boot-h2-database)
- [Wikipedia - H2 (DBMS)](https://ko.wikipedia.org/wiki/H2_(DBMS))

</details> <br/>

#### 꼭 알아야 할 데이터베이스 용어
- 테이블(Table): 테이블은 데이터베이스에서 데이터를 구성하기 위한 가장 기본적인 단위입니다. 테이블은 행과 열로 구성되며 행은 여러 속성으로 구성됩니다.
- 행(Row): 행은 테이블의 구성 요소 중 하나이며 테이블의 가로로 배열된 데이터의 집합을 의미합니다.<br/> 예를 들어 회원 테이블이 있따고 할때 ID 가 1번인 회원의 이메일, 나이 같은 정보가 모여 있는 집합이 1번 회원에 대한 행이라고 할 수 있죠. 행은 반드시 고유한 식별자인 기본키를 가집니다. 행을 레코드(record)라고 부르기도 합니다.
- 열(Column): 열은 테이블의 구성 요소 중 하나이며, 행에 저장되는 유형의 데이터입니다. <br/>예를 들어 회원 테이블이 있다고 할 때, 열은 각 요소에 대한 속성을 나타내며 무결성을 보장합니다. 지금의 경우 이메일은 문자열, 나이는 숫자 유형을 가집니다. 이메일 열에 숫자가 들어가거나, 나이 열에 문자열이 들어갈 수 없기 떄문에 데이터에 대한 무결성을 보장합니다.
- 기본키(Primary Key): 기본키는 행을 구분할 수 있는 식별자입니다. 이 값은 테이블에서 유일해야 하며 중복 값을 가질 수 없습니다. 보통 데이터를 수정하거나 삭제하고, 조회할 때 사용되며 다른 테이블과 관계를 맺어 데이터를 가져올 수도 있습니다. 또한 기본키의 값을 수정되어서는 안 되며 유효한 값이어야 합니다. 즉 NULL이 될 수 없습니다.
- Query: 쿼리는 데이터베이스에서 데이터를 조회하거나 삭제, 생성, 수정 같은 처리를 하기 위해 사용하는 명령문입니다. SQL이라는 데이터베이스 전용 언어를 사용하여 작성합니다.

> 무결성: 신뢰할 수 있는 서비스 제공을 위해서 의도하지 않은 요인에 의해 데이터, 소프트웨어, 시스템 등이 변경되거나 손상되지 않고 완전성, 정확성, 일관성을 유지함을 보장하는 특성.

### 5.2 ORM(Object−Relational Mapping)이란?
ORM은 자바의 객체와 데이터베이스를 연결하는 프로그래밍 기법입니다. 

예를 들어 데이터베이스에 age, name 컬럼에 20, 홍길동이라는 값이 들어있다고 생각해보죠. 이것을 자바에서 사용하려면 어떻게 해야 할까요? 

아마 다른 방법이 필요할 겁니다. 보통은 SQL이라는 언어로 데이터를 꺼내 사용하죠. 그러면 SQL을 새로 공부해야 하니 골치가 아픕니다!

```mermaid
graph LR
    A["자바 코드\nint age=20\nString name = '홍길동'"]
    B[ORM]
    C["RDB\nage: 20\nname: '홍길동'"]
    A <--> B <--> C
```

**하지만 ORM이 있다면 데이터베이스 값을 마치 객체처럼 사용할 수 있습니다.** 쉽게 말해 SQL을 전혀 몰라도 자바 언어로만 데이터베이스에 접근해서 원하는 데이터를 받아올 수 있죠. 

**즉, 객체와 데이터베이스를 연결해 자바 언어로만 데이터베이스를 다룰 수 있게 하는 도구를 ORM이라고 합니다.** 

ORM은 다음과 같이 장점과 단점이 있습니다.
- 장점
  1. SQL을 직접 작성하지 않고 사용하는 언어로 데이터베이스에 접근할 수 있습니다.
  2. 객체지향적으로 코드를 작성할 수 있기 떄문에 비즈니스 로직에만 집중할 수 있습니다.
  3. 데이터베이스 시스템이 추상화되어 있기 때문에 MySQL에서 PostgreSQL로 전환한다고 해도 추가로 드는 작업이 거의 없습니다. 즉, 데이터베이스 시스템에 대한 종속성이 줄어듭니다.
  4. 매핑하는 정보가 명화하기 때문에 ERD에 대한 의존도를 낮출 수 있고 유지보수할 때 유리합니다.
- 단점
  1. 프로젝트의 복잡성이 커질수록 사용 난이도가 올라갑니다.
  2. 복잡하고 무거운 쿼리는 ORM으로 해결이 불가능한 경우가 있습니다.

## 5.3 JPA(Java persistence API)와 하이버네이트(Hibernate)?
DBMS에도 여러 종류가 있는 것처럼 ORM에도 여러 종류가 있습니다. 자바에서는 **JPA**를 표준으로 사용합니다. 

JPA는 자바에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스인데요, 인테페이스 이므로 실제 사용을 위해서는 ORM 프레임워크를 추가로 선택햐야 합니다. 대표적으로는 **하이버네이트**를 많이 사용하죠. 

하이버네이트는 JPA 인터페이스를 구현한 구현체이자 자바용 ORM 프레임워크입니다. 내부적으로는 JDBC API를 사용하죠. 하이버네이트의 목표는 자바 객체를 통해 데이터베이스 종류에 상간없이 데이터베이스를 자유자재로 사용할 수 있게 하는 데 있습니다.

> JPA와 하이버네이트의 역할
> - JPA(Java Persistence API): 자바 객체와 데이터베이스를 연결해 데이터를 관리합니다. <br/>객체 지향 도메인 모델과 데이터베이스의 다리 역할을 합니다.
> - 하이버네이트(Hibernate) : JPA의 인터페이스를 구현합니다. 내부적으로는 JDBC API를 사용합니다.

```mermaid
graph TD
    A["애플리케이션"]
    B["스프링 데이터 JPA"]
    C["JPA"]
    D["하이버네이트"]
    E["JDBC"]
    F["데이터베이스"]
    A <--> B
    A <--> C
    E <--> F
```

### 5.3.1 엔티티 매니저란?
: JPA와 하이버네이트에 대해서 알아보았으니, JPA의 중요한 컨셉 중 하나인 **엔티티 매니저**와 **영속성 컨텍스트**를 알아보겠습니다.

#### 엔티티(Entity)
**엔티티는 데이터베이스의 테이블과 매핑되는 객체를 의미**합니다. 엔티티는 본질적으로 자바 객체이므로 일반 객체와 다르지 않습니다. 

**하지만 데이터베이스의 테이블과 직접 연결된다는 아주 특별한 특징**이 있어 구분지어 부릅니다. 즉, 엔티티는 객체이긴 하지만 데이터베이스에 영향을 미치는 쿼리를 실행하는 객체인 것이죠.

#### 엔티티 매니저(Entity manager)
엔티티를 관리해 데이터베이스와 애플리케이션 사이에서 객체를 생성, 수정, 삭제하는 등의 역할을 합니다.

그리고 이런 엔티티 매니저를 만드는 곳이 엔티티 매니저 팩토리(entity manager factory)입니다. 

앞서 데이터베이스에 여러 사용자가 접근할 수 있다고 했죠? 예를 들어 회원 2명이 동시에 회원 가입을 하려는 경우 엔티티 매니저는 다음과 같이 업무를 처리합니다. 

회원 1의 요청에 대해서 가입 처리를 할 엔티티 매니저를 엔티티 매니저 팩토리가 생성하면 이를 통해 가입 처리해 데이터베이스에 회원 정보를 저장하는 것이죠. 회원 2도 마찬가지입니다. 그리고 회원 1, 2를 위해 생성된 엔티티 매니저는 필요한 시점에 데이터베이스와 연결한 뒤에 쿼리합니다.

그렇다면 스프링 부트에서도 직접 엔티티 매니저 팩토리를 만들어서 관리할까요? 사실 그렇지 않습니다. 스프링 부트는 내부에서 엔티티 매니저 팩토리를 하나만 생성해서 관리하고 `@PersistenceContext` 또는 `@Autowired` 애너테이션을 사용해서 엔티티 매니저를 사용합니다.

```java
// 스프링 부트가 엔티티 매니저를 사용하는 방법 예
@PersistenceContext
EntityManager em; // 프록시 엔티티 매니저. 필요할 때 진짜 엔티티 매니저 호출
```

그리고 스프링 부트는 기본적으로 빈을 하나만 생성해서 공유하므로 동시성 문제가 발생할 수 있습니다. 그래서 **실제로는 엔티티 매니저가 아닌 실제 엔티티 매니저와 연결하는 프록시(가짜) 엔티티 매니저를 사용합니다.** 필요할 때 데이터베이스 트랜잭션과 관련된 실제 엔티티 매니저를 호출하는 겁니다.

> 쉽게 말해 엔티티 매니저는 Spring Data JPA에서 관리하므로 여러분이 직접 생성하거나 관리할 필요가 없습니다.

### 5.3.2 영속성 컨텍스트란?
또한 엔티티 매니저는 엔티티를 영속성 컨텍스트에 저장한다는 특징이 있습니다. 영속성 컨텍스트는 JPA의 중요한 특징 중 하나로, 엔티티를 관리하는 가상의 공간입니다. 이것이 있기 때문에 데이터베이스에서 효과적으로 데이터를 가져올 수 있고, 엔티티를 편하게 사용할 수 있는 것이죠.

영속성 컨텍스트에는 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩이라는 특징이 있는데요. 이 특징들에 대해서 간단하게 알아보겠습니다.

기존에는 데이터 조작을 위해 쿼리를 직접 작성해야 했지만 스프링 부트에서는 이런 쿼리를 자바 코드로 작성하고 이를 JPA가 알아서 쿼리로 변경해주는 것이 매우 편리합니다. 그래서 어떤 사람들은 JPA의 영속성 컨텍스트를 몰라도 괜찮다고 이야기하기도 합니다. 

하지만 필자는 이를 모르고 지나치면 자신의 의도하지 않은 방향으로 프로그램이 결과를 만들 수 있다고 생각합니다. 그래서 이런 상황을 대비해 영속성 컨텍스트의 기본적인 특징들을 알아 두기를 추천합니다.

#### 1차 캐시
영속성 컨텍스트는 내부에 1차 캐시를 가지고 있습니다. 

이때 캐시의 키는 엔티티의 `@Id` 애너테이션이 달린 기본키 역할을 하는 식별자이며 값은 엔티티입니다. 엔티티를 조회하면 1차 캐시에서 데이터를 조회하고 값이 있으면 반환합니다. 

값이 없으면 데이터베이스에서 조회해 1차 캐시에 저장한 다음 반환합니다. 이를 통해 캐시된 데이터를 조회할 떄에는 데이터베이스를 거치지 않아도 되믈 매우 빠르게 데이터를 조회할 수 있습니다.

#### 쓰기 지연(transactional write-behind)
트랜잭션을 커밋하기 전까지는 데이터베이스에 실제로 질의문을 보내지 않고 쿼리를 모았다가 트랜잭션을 커밋하면 모았던 쿼리를 한번에 실행하는 것을 의미합니다. 

예를 들어 데이터 추가 쿼리가 3개라면 영속성 컨텍스트는 트랜잭션을 커밋하는 시점에 3개의 쿼리를 한꺼번에 쿼리를 전송합니다. 이를 통해 적당한 묶음으로 쿼리를 요청할 수 있어 데이터베이스 시스템의 부담을 줄일 수 있습니다.

#### 변경 감지
트랜잭션을 커밋하면 1차 캐시에 저장되어 있는 엔티티의 값과 현재 엔티티의 값을 비교해서 변경된 값이 있다면 변경 사항을 감지해 변경된 값을 데이터베이스에 자동으로 반영합니다. 

이를 통해 쓰기 지연과 마찬가지로 적당한 묶음으로 쿼리를 요청할 수 있고, 데이터베이스 시스템의 부담을 줄일 수 있습니다.

#### 지연 로딩(lazy loading)
쿼리로 요청한 데이터를 애플리케이션에 바로 로딩하는 것이 아니라 필요할 때 쿼리를 날려 데이터를 조회하는 것을 의미합니다.

---
이 특징들의 갖는 공통적은 모두 데이터베이스의 접근을 최소화해 성능을 높일 수 있다는 겁니다. 캐시를 하거나, 자주 쓰지 않게 하거나, 변화를 자동 감지해서 미리 준비하거나 하는 등의 방법을 통해 말이죠. 이런 특징을 잘 이해하고 JPA를 사용한다면 문제 상황을 조금 더 잘 이해할 수 있을 겁니다.


### 5.3.3 엔티티의 상태
엔티티는 4가지 상태를 가집니다. 
1. 영속성 컨텍스트가 관리하고 있지 않은 분리(detached) 상태 
2. 영속성 컨텍스트가 관리하는 관리(managed) 상태
3. 영속성 컨텍스트와 전혀 관계가 없는 비영속(transient) 상태
4. 삭제된(removed) 상태로 나눠집니다. 

이 상태는 특정 메서드를 호출해 변경할 수 있는데요. 필요에 따라 엔티티의 상태를 조절해 데이터를 올바르게 유지하고 관리할 수 있습니다.

```java
// 엔티티 상태 변경 예
public class EntityManagerTest {
	@Autowired
    EntityManager em;
    
    public void example() {
    	// 1. 엔티티 매니저가 엔티티를 관리하지 않은 상태 (비영속 상태)
        Member member = new Member(1L, "홍길동");
        
        // 2. 엔티티가 관리되는 상태
        em.persist(member);
        // 3. 엔티티 객체가 분리된 상태
        em.detach(member);
        // 4. 엔티티 객체가 삭제된 상태
        em.remove(member);
    }
}
```
1. 엔티티를 처음 만들면 엔티티는 비영속 상태가 됩니다.
2. `persist()` 메서드를 사용해 엔티티를 관리 상태로 만들 수 있으며, `Member` 객체는 영속성 컨텍스트에서 상태가 관리됩니다. 
3. 만약 엔티티를 영속성 컨텍스트에서 관리하고 싶지 않다면 `detach()` 메서드를 사용해 분리 상태로 만들 수 있습니다.
4. 또한 더 이상 객체가 필요 없다면 `remove()` 메서드를 사용해서 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제할 수 있습니다.

## 5.4 스프링 데이터와 스프링 데이터 JPA
지금까지 배운 개념에서는 엔티티의 상태를 직접 관리하고, 필요한 시점에 커밋을 해야 하는 등의 개발자가 신경 써야 할 부분이 많습니다. 

스프링 데이터(spring data)는 비즈니스 로직에 더 집중할 수 있게 데이터베이스 사용 기능을 클래스 레벨에서 추상화했습니다. 스프링 데이터에서 제공하는 인터페이스를 통해서 스프링 데이터를 사용할 수 있습니다. 이 인터페이스는 CRUD를 포함한 여러 메서드가 포함되어 있으며, 알아서 쿼리를 만들어줍니다. 또한 이외에도 페이징 처리 기능과 메서드 이름으로 자동으로 쿼리를 빌딩하는 기능이 제공되는 등 많은 장점이 있습니다. 추가로 각 데이터베이스의 특성에 맞춰 기능을 확장해 제공하는 기술도 제공합니다. 

예를 들어 표준 스펙인 **JPA**는 스프링에서 구현한 스프링 데이터 JPA(spring data JPA)를, **몽고디비**는 스프링 데이터 몽고디비(spring data MongoDB)를 사용합니다. 이 책에서는 스프링 데이터 JPA를 살펴보겠습니다.

### 5.4.1 스프링 데이터 JPA란?
스프링 데이터 JPA는 스프링 데이터의 공통적인 기능에서 JPA의 유용한 기술이 추가된 기술입니다. 

스프링 데이터 JPA에서는 스프링 데이터의 인터페이스인 `PagingAndSortingRepository`를 상속받아 `JpaRepository` 인터페이스를 만들었으며, JPA를 더 편리하게 사용하는 메서드를 제공합니다. 지금까지는 다음과 같이 메서드 호출로 엔티티 상태를 바꿨습니다.

```java
// 메서드 호출로 엔티티 상태 변경 예
@PersistenceContext
EntityManager em;

public void join() {
	// 기존에 엔티티 상태를 바꾸는 방법 (메서드를 호출해서 상태 변경)
    Member member = new Member(1L, "홍길동");
    em.persist(member);
}
```

하지만 스프링 데이터 JPA를 사용하면 리포지터리 역할을 하는 인터페이스를 만들어 데이터베이스의 테이블 조회, 수정, 생성, 삭제 같은 작업은 간단히 할 수 있습니다. 다음과 같이 `JpaRepository` 인터페이스를 우리가 만든 인터페이스에서 상속받고, 제네릭에는 관리할 <엔티티 이름, 엔티티 기본키의 타입> 을 입력하면 기본 CRUD 메서드를 사용할 수 있습니다.
```java
// 기본 CRUD 메서드를 사용하기 위한 JpaRepository 상속 예
public interface MeberRepository extends JpaRepository<Member, Long> {
}
```

### 5.4.2 스프링 데이터 JPA에서 제공하는 메서드 사용해보기
#### 01 단계
그러면 `JpaRepository`에서 제공하는 메서드의 사용 방법을 살펴보겠습니다. `springbootdeveloper` 패키지에 `MemberService.java`를 생성해 코드를 작성하세요.

```java
@Service
public class MemberService {
    
    @Autowired
    MemberRepository memberRepository;
    
    public void test() {
        // 1. 생성 (Create)
        memberRepository.save(new Member(1L, "A"));
        
        // 2. 조회 (Read)
        Optional<Member> member = memberRepository.findById(1L); //단건 조회
        List<Member> allMembers = memberRepository.findAll();    //전체 조회
        
        // 3. 삭제 (Delete)
        memberRepository.deleteById(1L);
    }
}
```
1. `save()` 메서드를 호출해 데이터 객체를 저장할 수 있습니다. 전달 인수로 엔티티 Member를 넘기면 반환값으로 저장한 엔티티를 반환받을 수 있습니다. 
2. `findById()` 메서드에 id를 지정해 엔티티 하나를 조회할 수 있습니다. <br/>`findAll()` 메서드는 전체 엔티티를 조회합니다. 
3. `deleteById()` 메서드에 id를 지정하면 엔티티를 삭제할 수 있습니다.

> `delete()` 메서드를 호출해 엔티티 전달 인수로 넘겨 삭제할 수도 있습니다.

## 5.5 예제 코드 살펴보기
지금까지 많은 애너테이션을 사용했는데 이제 애너테이션이 어떤 역할을 하는지 알아볼 차례입니다. 코드를 다시 열어 어떤 애너테이션들을 사용했는지 확인해봅시다.

### 1단계
`Member.java` 파일을 열어보세요
```java
@Entity // 1. 엔티티로 지정
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED) // 2. 기본 생성자
@AllArgsConstructor
public class Member {

    @Id // 3. id 필드를 기본키로 지정
    @GeneratedValue(strategy = GenerationType.IDENTITY) // 4. 기본키를 자동으로 1씩 증가
    @Column(name = "id", updatable = false)
    private Long id;  //DB 테이블의 'id' 컬럼과 매칭

    @Column(name = "name", nullable = false) // 5. name 이라는 not null 컬럼과 매핑
    private String name; //DB 테이블의 'name' 칼럼과 매칭
}
```

#### 1. `@Entity`
`@Entity` 애너테이션은 Member 객체를 JPA가 관리하는 엔티티로 지정합니다. 즉, Member 클래스와 실제 데이터베이스의 테이블을 매핑시킵니다. 

`@Entity`의 속성 중에 name을 사용하면 name의 값을 가진 테이블 이름과 매핑되고, 테이블 이름을 지정하지 않으면 클래스 이름과 같은 이름의 테이블과 매핑됩니다.  
여기서는 테이블 이름을 지정하지 않았으므로 클래스 이름과 같은 데이터베이스의 테이블이 member 테이블과 매핑됩니다.  
`@Entity` 애너테이션에서 테이블을 지정하고 싶다면 다음과 같이 name 파라미터에 값을 지정해주세요.
```java
// name 파라미터로 Article 클래스와 member_list 테이블 매핑하기 예
@Entity(name = "member_list")  // "member_list" 라는 이름을 가진 테이블과 매핑
public class Article {
	// ... 생략 ...
}
```

#### 2. `protected` 기본 생성자
`protected` 기본 생성자입니다. 엔티티는 반드시 기본 생성자가 있어야 하고, 접근 제어자는 `public` 또는 `protected` 여야 합니다. 

`public` 보다는 `protected` 가 더 안전하므로 접근 제어자가 `protected`인 기본 생성자를 생성합니다. 

#### 3. `@Id`
`@Id`는 `Long` 타입의 id 필드를 테이블의 기본키로 지정합니다. 

#### 4.`@GeneratedValue`
`@GeneratedValue`는 기본키의 생성 방식을 결정합니다. 여기서는 자동으로 기본키가 증가되도록 지정했습니다. 자동키 생성 설정 방식은 다음과 같습니다.

- 자동키 생성 설정 방식
  - AUTO : 선택한 데이터베이스 방언(dialect)에 따라 방식을 자동으로 선택(기본값)
  - IDENTITY : 기본키 생성을 데이터베이스에 위임(= AUTO_INCREMENT)
  - SEQUENCE : 데이터베이스 시퀀스를 사용해서 기본키를 할당하는 방법, 오라클에서 주로 사용
  - TABLE : 키 생성 테이블 사용

#### 5.`@Column`
`@Column` 애너테이션은 데이터베이스의 칼럼과 필드를 매핑해줍니다. 대표적인 `@Column` 애너테이션의 속성을 알아보겠습니다.

- `@Column` 애너테이션의 속성
  - name : 필드와 매핑할 컬럼 이름. 설정하지 않으면 필드 이름으로 지정해줍니다.
  - nullable : 컬럼의 null 허용 여부, 설정하지 않으면 true(nullable)
  - unique : 컬럼의 유일한 값(unique) 여부. 설정하지 않으면 false(non unique)
  - columnDefinition : 칼럼 정보 설정. default 값을 줄 수 있습니다.

### 2단계
`MemberRepository.java` 파일도 열어봅니다.
```java
@Repository
public interface MemberRepository extends JpaRepository<Member, Long> {
}
```
`@Repository`는 엔티티에 있는 데이터들을 조회하거나 저장, 변경, 삭제를 할 때 사용하는 인터페이스로, 스프링 데이터 JPA에서 제공하는 인터페이스인 `JpaRepository` 클래스를 상속받아 간단하게 구현할 수 있습니다.

```mermaid
graph LR
  A["사용자"]
  B["리포지토리 <br/> (MemberRepository.java)"]
  C["DB <br/> (member)"]
  D["엔티티 <br/> (Member.java)"]
  A -->|"요청"| B -->|"조회"| C --> D
  D --> C -->|"응답"| B -->|"응답"| A
```

`JpaRepository` 클래스를 상속받을 때, 엔티티 Member와 엔티티의 기본키 타입 Long을 인수로 넣어줍니다. 이제 해당 리포지토리를 사용할 때 `JpaRepository` 에서 제공하는 여러 메서드를 사용할 수 있게 됩니다.

## 핵심 요약
1) ORM 은 객체와 데이터베이스를 연결하는 프로그래밍 기법입니다.
2) JPA 는 자바에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스입니다.
   + 엔티티는 영속성을 가진 객체를 의미합니다.
   + 엔티티 매니저는 엔티티를 관리하며 조회, 삭제, 수정, 생성하는 역할을 합니다.
   + 엔티티 매니저를 만드는 곳이 엔티티 매니저 팩토리입니다.